#!/bin/bash
#
# shadowmanager main program, the computer science internal assigment.
#
# usage: shadowmanager <command> [arguments ...]
# use './shadowmanager usage' for more informations.

cd "$(dirname "$0")"

. ./conf/shadowmanager.conf
. ./lang/$LANGUAGE.lng

for inc in $(ls ./include/)
do
	. ./include/$inc
done

for _hook in $(ls ./hooks/)
do
	. ./hooks/$_hook
done

function hook {
	declare -F $1 > /dev/null
	[[ ! $? == 0 ]] && return 0
	$1
}

function ifroot {
	[[ $CHECK_ROOT == "true" && "$(id -u)" != "0" ]] && {
		echo "$ROOT_REQUIRED"
		exit 1
	}
}

# show: show handling servers
# usage: show

function show {
	id=0
	[[ ! -z $1 ]] && _servers=$SHADOW_CONF.tmp || _servers=$SHADOW_CONF
	echo "ID	(method){port,password}"
	for _server in $(cat $_servers)
	do
		let id++
		echo "$id	$_server"
	done
}

# remove: remove a handling server
# usage: remove <id>

function remove {
	[[ -z $1 ]] && echo "remove: $MISSING_ARGS" && return 1
	sed -e "${1}d" $SHADOW_CONF > $SHADOW_CONF.tmp
	show -i
	read -p "$SAVE_SERVER" yn
	case $yn in
		y|Y|yes|Yes)
			mv $SHADOW_CONF.tmp $SHADOW_CONF
		;;
		*)
			echo "$ABORTED"
		;;
	esac
}

# add: add a server
# usage: add <port> <pass> <method>

function add {
	[[ -z $3 ]] && echo "add: $MISSING_ARGS" && return 1
	[[ $(verify $*) == "false" ]] && echo "$CONTAIN_INVALID_CHARS" && return 1
	[[ -e $SHADOW_CONF && ! -z $(cat $SHADOW_CONF | grep {$1, | awk -F{ '{print $2}' | awk -F, '{print $1}') ]] && echo "$PORT_ALREADY_IN_USE" && return 1
	[[ -z $(echo $METHODS | grep \ $3\ ) ]] && echo $(echo "$ERR_METHOD_NOT_EXIST"|sed -e "s/__METHOD__/$3/") && return 1
	hook pre-add
	echo "($3){$1,$2}" >> $SHADOW_CONF
	echo $SERVER_ADDED
	hook post-add
}

# verify: verify if the input is valid
# usage: verify <string>

function verify {
	for char in $INVALID_CHARS
	do
		if [[ $* == *$char* ]]
		then
			echo false; return
		fi
	done
}

# genconf: generate the shadowsocks config file

function genconf {
	hook pre-genconf
	rm -f $SHADOW_JSON_DIR/* 2> /dev/null
	[[ ! -e $SHADOW_JSON_DIR ]] && mkdir $SHADOW_JSON_DIR
	echo -n "$GEN_SS_CONF"
	for method in $METHODS
	do
		{
			[[ ! -z $(cat $SHADOW_CONF|grep \($method\)) ]] && {
				servers=$(cat $SHADOW_CONF|grep \($method\)|sed '$ d')
				_last=$(cat $SHADOW_CONF|grep \($method\)|tail -n1)
				echo $SHADOWSOCKS_JSON_PRE > $SHADOW_JSON_DIR$method.conf.tmp
				for server in $servers
				do
					_port=$(echo $server|awk -F "[{},]" '{print $2}')
					_pass=$(echo $server|awk -F "[{},]" '{print $3}')
					echo "\"$_port\": \"$_pass\"," >> $SHADOW_JSON_DIR$method.conf.tmp
				done
				_port=$(echo $_last|awk -F "[{},]" '{print $2}')
				_pass=$(echo $_last|awk -F "[{},]" '{print $3}')
				echo "\"$_port\": \"$_pass\"" >> $SHADOW_JSON_DIR$method.conf.tmp
				echo $SHADOWSOCKS_JSON_EXT >> $SHADOW_JSON_DIR$method.conf.tmp
				cat $SHADOW_JSON_DIR$method.conf.tmp|sed -e "s/__FAST_OPEN__/$TCP_FAST_OPEN/; s/__METHOD__/$method/;" > $SHADOW_JSON_DIR$method.conf
				rm $SHADOW_JSON_DIR$method.conf.tmp
			}
		} &
	done
	wait
	echo $DONE
	hook post-genconf
}

function status {
	[[ -e $PIDS ]] && echo $SHADOWMANAGER_RUNNING || echo $SHADOWMANAGER_NOT_RUNNING
}

# start: start shadowservers

function start {
	[[ -e $PIDS ]] && echo start: $ERR_RUNNING && return 1
	genconf
	[[ ! -e $LOGDIR ]] && mkdir $LOGDIR
	echo -n "$STARTING_SERVERS"
	cd $SHADOW_JSON_DIR
	hook pre-start
	for server in $(ls)
	do
		_log=$server-$(date +%Y-%m-%d_%H:%M:%S)
		$(echo $SHADOW_CMD|sed -e "s/__CONFIG__/$server/") 2>> ../../$LOGDIR/$_log >> ../../$LOGDIR/$_log
		[[ -z $(cat $SS_PID) ]] && echo $ERR_CAN_NOT_START && stop && crash 1
		echo $(cat $SS_PID) >> $PIDS
		rm $SS_PID
	done
	echo $DONE
	hook post-start
}

function stop {
	[[ ! -e $PIDS ]] && echo stop: $ERR_NOT_RUNNING && return 1
	hook pre-stop
	echo -n "$STOPPING_SERVERS"
	for kill in $(cat $PIDS)
	do
		kill $kill > /dev/null 2> /dev/null
	done
	rm -f $PIDS
	echo $DONE
	hook post-stop
}

function restart {
	stop; start
}

function crash {
	stop; exit $1
}

function usage {
	echo '
shadowmanager is a script to maintaince multiple shadowsocks server with
different encryption method at a time.

shadowsocks-python is tested and it works.

usage: shadowmanager add <port> <password> <method>
                     start
                     stop
                     restart
                     status
                     show
                     remove <id>
                     enovr [overrides ...]
                     disovr [overrides ...]

commands explained:

	add:     add a server to shadowmanager handler, accepting 3 parameters,
	         port, password and method.
	start:   start shadowmanager, no parameters required.
	stop:    stop shadowmanager, no parameters required.
	restart: restart shadowmanager, no parameters required.
	show:    show all the servers handling, no parameters required.
	status:  show shadowmanager running status, no parameters required.
	remove:  remove server with given ID. Use "show" command to show all
	         servers, accepting 1 parameter, server ID.
	enovr:   enable one or more overrides, accepting override names as
	         parameters (optional).
	disovr:  disable one or more overrides, accepting override names as
	         parameters (optional).
'
	_show-extra-helps
}

function _show-extra-helps {
	[[ -e .shadowmanager.extrahelp ]] && {
		echo $USAGE_EXTRA; echo
		cat .shadowmanager.extrausage; echo
	}
	[[ -e .shadowmanager.extrahelp ]] && {
	echo $HELP_EXTRA; echo
	cat .shadowmanager.extrahelp; echo
	}
}

for ovr in $(ls ./override/)
do
        . ./override/$ovr
done

ifroot
[[ -z $* ]] && usage || $*
